**JWT** (*JSON Web Token*) - Спеціальний стандарт (*RFC 7519*) який використовують безпечної та компактної передачі інформації у вигляді JSON об'єкта.
#### Безпека та верифікація
Для верифікація та підтвердження інформації, токен використовує електронний підпис такий як *HMAC* або використання *private/public* ключів *RSA* або *ECDSA* 
У підписаних токенах можна переглядати claims, тоді як зашифрована інформація залишатиметься недоступною.
Використання _private/public_ ключів також гарантує справжність підпису, оскільки лише одна зі сторін має приватний ключ для підписання..

#### Приклади застосування
- **Авторизація** - Це найбільш поширений сценарій по скільки після авторизації в токені можна зберігати інформація до прикладу права доступу до функціоналу. 
- **Обмін інформацією** - **JWT** також використовують для безпечного обміну інформацією. Використання пари приватного та публічного ключа дозволяє перевірити, що відправник є справжнім.. Також через те що підпис залежить від сигнатури токену (header, payload) ви можете бути впевненими що інформація не була сфабрикована

#### Структура JWT
Структура поділяється на 3 основні частини та розділений за допомогою |`.`|
1. Header(Заголовок)
2. Payload(Вміст)
3. Signature(Підпис)

*Приклад структури* - |`xxxxx.yyyyy.zzzzz` 
##### Детальніше про структура
- **Header** - Зазвичай складається з 2 частин:
	1. **Тип** - (JWT)
	2. **Алгоритму підписання** -  (**HMAC SHA256 або RSA**)
	Ця частина конвертується в **Base64Url** та формує першу частину токену
  Приклад хедеру - 
  `{ "alg": "HS256", "typ": "JWT" }`
- **Payload** - Друга частина токену яка містить в собі claims, це комірки з інформацією про сутність (зазвичай про користувача) та додаткові дані.
	Claims поділяються на 3 типи
	-  Registered(Зареєстровані) - Це перелік загальних claim які не обов'язкові але гарною практикою вважається їх використання. Приклад: **iss**, **exp**, **aud** та інші.
	- Public(Публічні) - Тип claim які визначають для чого буде використовуватись токен, проте воно має бути визначений в [IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) аби уникнути колізій, або використання спеціальних URL які теж гарантуватимуть відсутність повторень
	- Private(Приватні) - Кастомні клейми які використовуються для передачі інформації проте не є не зареєстрованими чи публічними
	###### **Більше про зареєстровані клейми**
	 - **iss(Issuer)** - Видавець токену, зазвичай містить url або string
	 - **sub(Subject)** - Визначає предмет ким є токен який маж бути унікальним глобально або відносно одного issuer
	 - **aud(Audience)** - Визначає отримувача токену та повинен перевірятися, у випадку якщо для отримувача прийшов токен який не був призначений для нього він повинен його відхилити
	 - **exp(Expiration time)** - Містить інформацію коли токен перестає бути дійсним
	 Для більш детального ознайомлення з клеймами можна перейти за посиланням [Datatracker](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1)
	Приклад payload - `{"sub": "1234567890", "name": "John Doe", "admin": true }`
	Також конвертується в **Base64Url**
-  **Signature** - Заключна частина токену яка містить в собі закодований header та payload, secret, алгоритм підписання які використовуються для підпису.
	Для прикладу якщо JWT підписувати через HMAC SHA256 то його сигнатура підпису буде виглядати наступним чином
	`HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`
	Ця частина використовується для підтвердження що токен по дорозі не був змінений та збережені заходи безпеки які були описані в попередньому пункті
#### Загальний вигляд JWT
Загалом це три **Base64URL** стрінги які розділені крапкою з яким легко працювати в **html** та **http** середовищах. За розміром він є менший ніж токени які базуються на **XML** (**SAML**)
*Приклад токену який був створений на попередньо продемонстрованих даних*
![[img/jwt_example.png]]
Для розкодування та перевірки власних JWT ви можете використати цей сайт **[jwt.io](https://jwt.io/)**
#### Як працює JWT
До прикладу коли користувач авторизується у відповідь приходить токен з відповідною інформацією про користувача. Проте потрібно пам'ятати про безпеку і не зберігати токен більше чим потрібно та не зберігати в ньому конфідеційну інформацію.
##### Надсилання токену на захищені роути
Якщо користувач надсилає запит на захищений роут то як правило токен надсилається в **Authorization** хедері з використанням **Bearer** схеми
Коректний вигляд:
`Authorization: Bearer <token>`
Також **JWT** можна передавати в тілі самого запиту але це є менш безпечним варіантом
###### **Запит на сервер**
Коли на сервер приходить запит на захищений роут тоді JWT проходить перевірку, у разі задовільнення всіх вимог машруту (Не пустий та не протермінований JWT, та інше), сервер поверне відповідний результат
###### **Застереження в розмірі токену**
Якщо ви надсилаєте JWT в http то повинні пам'ятати що здебільшого сервери не приймають хедери з розміром більше 8KB, проте деякі проксі сервери підтримують розмір лише до 2 KB, якщо вам потрібно зберігати багато інформації наприклад параметри доступу користувача, тоді можливо вам потрібно обрати інший підхід авторизації як [fga.dev](https://fga.dev/)
###### CORS
Якщо JWT передається в заголовку запиту, то проблем із **Cross-Origin Resource Sharing** (**CORS**) зазвичай не виникає, оскільки він не використовує cookies. Однак, якщо JWT все ж передається через cookies, можуть з'явитися обмеження, пов'язані з політикою безпеки браузера.
###### **Приклад роботи** з API (Авторизація)
Роботу з Api можна поділити в 3 етапи
1. **Надсилання запиту** - Коли користувач надсилає запит на відповідний роут (приклад: `/auth/login`), сервер починає його оброблювати
2. **Обробка та повернення результату** - У разі успішної обробки запиту сервер поверне access_token(jwt) який можна буде використовувати в майбутньому
3. **Робота з access_token** - Коли ви отримали JWT ви можете його використовувати як для доступу до закритих роутів
***Примітка:*** Потрібно пам'ятати якщо користувач чи інша сторона не може змінити токен то вони все ще можуть отримати доступ до інформації через що не варто зберігати конфіденційну інформацію в ньому 
#### Чому варто використовувати JWT 
Розглянемо чому варто використовувати JWT на інших токенах таких як **Simple Web Tokens (SWT)** та **Security Assertion Markup Language Tokens (SAML)** 
JSON в порівнянні з XML є більш компактним через що SAML за розміром є більшим ніж JWT. Також це робить його одним з найкращих варіантів для передавання його в **html** та **http**
###### **Підписання**
**SWT** може бути підписаний тільки загальним ключем та лише **HMAC** алгоритмом тим часом як **JWT** та **SAML** можуть використовувати public/private keys з **X.509** сертифікатом. Підписання SAML без порушення безпеки є складнішим, ніж у JWT.
###### **Переваги парсингу**
**JSON** парсер вбудований в багатьох мовах програмування через свій простий мапінг в об'єкт. Тим часом як **XML** є складнішим відносно його мапінгу в об'єкт. Це робить роботу з **JWT** простішим аніж **SAML**
###### **Поширеність** 
**JWT** особливо поширений в інтернет маштабі, його активно використовують на клієнтській частині та мобільних пристроях
#### **Підсумок**
JWT є найкращим варіантом передачі передачі даних через його простоту використання, та безпеку порівняно з іншими варіантами 